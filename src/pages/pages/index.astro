---
import Layout from "../layouts/Layout.astro";
---

<Layout title="Astro Mini Game">
  <div
    class="flex items-center justify-center min-h-screen bg-gradient-to-b from-slate-900 to-slate-800 px-4"
  >
    <div
      class="w-full max-w-3xl bg-white/5 backdrop-blur-md rounded-2xl shadow-xl p-8 border border-white/10 text-center"
    >
      <h1 class="text-3xl font-bold text-white mb-3">üöÄ Click the Asteroid!</h1>
      <p class="text-lg text-slate-300 mb-4">
        Avoid space debris and click asteroids to score points!
      </p>

      <!-- Game Rules -->
      <div id="gameRules" class="mb-4 p-4 bg-white/10 rounded-lg border border-white/20">
        <h3 class="text-lg font-bold text-white mb-2">üìã Game Rules</h3>
        <ul class="text-sm text-slate-300 text-left space-y-1">
          <li>‚úÖ <strong>Click asteroids</strong> (colorful) to score <span class="text-green-400">+1 point</span></li>
          <li>‚ùå <strong>Click debris</strong> (red-outlined) to lose <span class="text-red-400">1 life</span></li>
          <li>‚ö†Ô∏è <strong>Miss an asteroid</strong> (goes off-screen) to lose <span class="text-yellow-400">1 point</span></li>
          <li>üíî You have <strong>3 lives</strong> ‚Äî game over when you lose all lives!</li>
        </ul>
      </div>

      <!-- Start/Restart Button -->
      <div id="startScreen" class="mb-4">
        <button 
          id="startBtn"
          class="px-8 py-3 text-xl font-bold rounded-xl bg-gradient-to-r from-indigo-500 to-purple-600 text-white transition-all hover:from-indigo-600 hover:to-purple-700 hover:scale-105 active:scale-95 focus:outline-none focus:ring-2 focus:ring-purple-400 shadow-lg shadow-purple-500/50 animate-pulse"
        >
          üöÄ Start Game
        </button>
      </div>

      <canvas
        id="gameCanvas"
        width="900"
        height="700"
        class="rounded-lg shadow-lg border border-slate-600 bg-slate-900/70 touch-none"
        style="display: none;"
        role="img"
        aria-label="Game canvas with moving asteroid"
        tabindex="0"
      ></canvas>

      <div id="gameStats" style="display: none;">
        <p class="mt-6 text-xl text-slate-200">
          Score: <span id="score" class="font-bold text-indigo-400" aria-live="polite">0</span>
          <span class="mx-4">|</span>
          Lives: <span id="lives" class="font-bold text-red-400" aria-live="polite">3</span> ‚ù§Ô∏è
        </p>
      </div>

      <div id="gameOver" style="display: none;" class="mt-6">
        <h2 class="text-2xl font-bold text-red-400 mb-3">Game Over!</h2>
        <p class="text-lg text-slate-300 mb-4">Final Score: <span id="finalScore" class="font-bold text-indigo-400">0</span></p>
        <button 
          id="restartBtn"
          class="px-6 py-3 text-lg font-bold rounded-xl bg-gradient-to-r from-indigo-500 to-purple-600 text-white transition-all hover:from-indigo-600 hover:to-purple-700 hover:scale-105 active:scale-95 focus:outline-none focus:ring-2 focus:ring-purple-400 shadow-lg"
        >
          üîÑ Play Again
        </button>
      </div>

      <p class="mt-2 text-sm text-slate-400">
        Click asteroids to score points. Use Tab to navigate.
      </p>

      <div class="mt-8">
        <a
          href="/"
          class="px-6 py-3 text-lg font-medium rounded-xl bg-indigo-500 hover:bg-indigo-600 active:scale-95 shadow-md shadow-indigo-500/30 text-white transition-all"
        >
          ‚Üê Back to Home
        </a>
      </div>

      <footer
        class="mt-10 text-center text-slate-500 text-sm border-t border-slate-700 pt-4"
      >
        <p>
          Created by <a
            href="https://github.com/mhaques"
            target="_blank"
            class="text-indigo-400 hover:underline">mhaques</a>
        </p>
        <p class="mt-1">
          Source code available on <a
            href="https://github.com/mhaques/astrolab"
            target="_blank"
            class="text-indigo-400 hover:underline">GitHub</a>
        </p>
      </footer>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    if (!canvas) throw new Error("gameCanvas not found");
    const ctx = canvas.getContext("2d");
    if (!ctx) throw new Error("2D context not supported");

    const scoreEl = document.getElementById("score");
    const livesEl = document.getElementById("lives");
    const finalScoreEl = document.getElementById("finalScore");
    const startBtn = document.getElementById("startBtn");
    const restartBtn = document.getElementById("restartBtn");
    const startScreen = document.getElementById("startScreen");
    const gameStats = document.getElementById("gameStats");
    const gameOverScreen = document.getElementById("gameOver");

    let asteroid = { x: 100, y: 100, size: 40, velocityY: 0, velocityX: 0, rotation: 0, color: 0, shape: [], trail: [] };
    let obstacles = [];
    let score = 0;
    let lives = 3;
    let gameRunning = false;
    let animationId = null;
    let particles = [];
    let invulnerable = false;

    // Generate random asteroid shape with variation
    function generateAsteroidShape() {
      const points = [];
      const numPoints = 8 + Math.floor(Math.random() * 4);
      for (let i = 0; i < numPoints; i++) {
        const angle = (Math.PI * 2 * i) / numPoints;
        const variance = 0.7 + Math.random() * 0.6;
        points.push({ angle, variance });
      }
      return points;
    }

    // Random color variation
    function getAsteroidColor() {
      const colors = [
        { start: "#ffaa44", mid: "#ff9933", end: "#ff6633" },
        { start: "#aa88ff", mid: "#8866dd", end: "#6644bb" },
        { start: "#ff6688", mid: "#dd4466", end: "#bb2244" },
        { start: "#88ffaa", mid: "#66dd88", end: "#44bb66" }
      ];
      return colors[Math.floor(Math.random() * colors.length)];
    }

    function drawFireTrail() {
      // Draw fire trail behind asteroid
      asteroid.trail.forEach((pos, i) => {
        const alpha = (i / asteroid.trail.length) * 0.6;
        const size = asteroid.size * 0.7 * (i / asteroid.trail.length);
        
        const gradient = ctx.createRadialGradient(
          pos.x, pos.y, 0,
          pos.x, pos.y, size
        );
        gradient.addColorStop(0, `rgba(255, 220, 100, ${alpha})`);
        gradient.addColorStop(0.5, `rgba(255, 100, 50, ${alpha * 0.7})`);
        gradient.addColorStop(1, `rgba(255, 50, 0, ${alpha * 0.3})`);
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawAsteroid() {
      const colorScheme = getAsteroidColor();
      
      // Draw asteroid with gradient and irregular shape
      const gradient = ctx.createRadialGradient(
        asteroid.x, asteroid.y, 0,
        asteroid.x, asteroid.y, asteroid.size
      );
      gradient.addColorStop(0, asteroid.color.start);
      gradient.addColorStop(0.5, asteroid.color.mid);
      gradient.addColorStop(1, asteroid.color.end);
      
      ctx.save();
      ctx.translate(asteroid.x, asteroid.y);
      ctx.rotate(asteroid.rotation);
      
      // Draw irregular shape
      ctx.beginPath();
      asteroid.shape.forEach((point, i) => {
        const x = Math.cos(point.angle) * asteroid.size * point.variance;
        const y = Math.sin(point.angle) * asteroid.size * point.variance;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.closePath();
      
      ctx.fillStyle = gradient;
      ctx.fill();
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.stroke();

      // Add some crater details with variation
      ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
      const numCraters = 2 + Math.floor(Math.random() * 2);
      for (let i = 0; i < numCraters; i++) {
        const cx = (Math.random() - 0.5) * asteroid.size * 0.6;
        const cy = (Math.random() - 0.5) * asteroid.size * 0.6;
        const size = 3 + Math.random() * 5;
        ctx.beginPath();
        ctx.arc(cx, cy, size, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.restore();
    }

    function drawParticles() {
      particles = particles.filter(p => p.life > 0);
      
      particles.forEach(p => {
        p.x += p.velocityX;
        p.y += p.velocityY;
        p.life -= 0.02;
        p.velocityY += 0.1; // gravity
        
        ctx.fillStyle = `rgba(255, 170, 68, ${p.life})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function createExplosion(x, y) {
      for (let i = 0; i < 20; i++) {
        const angle = (Math.PI * 2 * i) / 20;
        const speed = 2 + Math.random() * 3;
        particles.push({
          x,
          y,
          velocityX: Math.cos(angle) * speed,
          velocityY: Math.sin(angle) * speed,
          life: 1,
          size: 2 + Math.random() * 3
        });
      }
    }



    function spawnFallingAsteroid() {
      asteroid.x = Math.random() * (canvas.width - asteroid.size * 2) + asteroid.size;
      asteroid.y = -asteroid.size;
      // Random direction - mostly down but with some horizontal drift
      const angle = (Math.PI / 2) + (Math.random() - 0.5) * (Math.PI / 3);
      const speed = 2 + Math.random() * 2;
      asteroid.velocityX = Math.cos(angle) * speed * 0.5;
      asteroid.velocityY = Math.sin(angle) * speed;
      asteroid.rotation = Math.random() * Math.PI * 2;
      asteroid.shape = generateAsteroidShape();
      asteroid.color = getAsteroidColor();
      asteroid.trail = [];
    }

    // Space debris (obstacles)
    function createObstacle() {
      const size = 20 + Math.random() * 25;
      const x = Math.random() * canvas.width;
      const angle = (Math.PI / 2) + (Math.random() - 0.5) * (Math.PI / 2);
      const speed = 1.5 + Math.random() * 2.5;
      
      return {
        x,
        y: -size,
        size,
        velocityX: Math.cos(angle) * speed * 0.6,
        velocityY: Math.sin(angle) * speed,
        rotation: Math.random() * Math.PI * 2,
        rotationSpeed: (Math.random() - 0.5) * 0.08,
        type: Math.random() > 0.5 ? 'debris' : 'satellite'
      };
    }

    function drawObstacle(obs) {
      ctx.save();
      ctx.translate(obs.x, obs.y);
      ctx.rotate(obs.rotation);
      
      if (obs.type === 'debris') {
        // Metallic space debris
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, obs.size);
        gradient.addColorStop(0, "#aaaaaa");
        gradient.addColorStop(0.5, "#777777");
        gradient.addColorStop(1, "#444444");
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.moveTo(-obs.size, 0);
        ctx.lineTo(0, -obs.size * 0.7);
        ctx.lineTo(obs.size, 0);
        ctx.lineTo(0, obs.size * 0.7);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = "#ff4444";
        ctx.lineWidth = 2;
        ctx.stroke();
      } else {
        // Broken satellite
        ctx.fillStyle = "#666666";
        ctx.fillRect(-obs.size * 0.6, -obs.size * 0.4, obs.size * 1.2, obs.size * 0.8);
        
        ctx.fillStyle = "#ff4444";
        ctx.fillRect(-obs.size * 0.9, -obs.size * 0.15, obs.size * 0.3, obs.size * 0.3);
        ctx.fillRect(obs.size * 0.6, -obs.size * 0.15, obs.size * 0.3, obs.size * 0.3);
        
        ctx.strokeStyle = "#ffaa00";
        ctx.lineWidth = 2;
        ctx.strokeRect(-obs.size * 0.6, -obs.size * 0.4, obs.size * 1.2, obs.size * 0.8);
      }
      
      ctx.restore();
    }

    function updateObstacles() {
      // Spawn new obstacles (reduced spawn rate to make it easier)
      if (gameRunning && Math.random() < 0.008) {
        obstacles.push(createObstacle());
      }
      
      // Update and remove off-screen obstacles
      obstacles = obstacles.filter(obs => {
        obs.x += obs.velocityX;
        obs.y += obs.velocityY;
        obs.rotation += obs.rotationSpeed;
        return obs.y < canvas.height + obs.size * 2;
      });
    }

    function loseLife() {
      lives--;
      if (livesEl) livesEl.textContent = String(lives);
      
      invulnerable = true;
      setTimeout(() => { invulnerable = false; }, 1500);
      
      // Flash effect
      let flashes = 0;
      const flashInterval = setInterval(() => {
        canvas.style.opacity = flashes % 2 === 0 ? '0.3' : '1';
        flashes++;
        if (flashes > 6) {
          clearInterval(flashInterval);
          canvas.style.opacity = '1';
        }
      }, 150);
      
      if (lives <= 0) {
        endGame();
      }
    }

    function endGame() {
      gameRunning = false;
      if (animationId) cancelAnimationFrame(animationId);
      if (finalScoreEl) finalScoreEl.textContent = String(score);
      canvas.style.display = 'none';
      gameStats.style.display = 'none';
      const gameRules = document.getElementById('gameRules');
      if (gameRules) gameRules.style.display = 'block';
      gameOverScreen.style.display = 'block';
    }

    function startGame() {
      score = 0;
      lives = 3;
      obstacles = [];
      particles = [];
      invulnerable = false;
      gameRunning = true;
      
      if (scoreEl) scoreEl.textContent = '0';
      if (livesEl) livesEl.textContent = '3';
      
      startScreen.style.display = 'none';
      gameOverScreen.style.display = 'none';
      const gameRules = document.getElementById('gameRules');
      if (gameRules) gameRules.style.display = 'none';
      canvas.style.display = 'block';
      gameStats.style.display = 'block';
      
      startGameMode();
    }

    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw fire trail first
      drawFireTrail();
      
      // Draw obstacles
      obstacles.forEach(obs => drawObstacle(obs));
      
      // Draw asteroid with flash effect if invulnerable
      if (invulnerable && Math.floor(Date.now() / 100) % 2 === 0) {
        ctx.globalAlpha = 0.5;
      }
      drawAsteroid();
      ctx.globalAlpha = 1;
      
      drawParticles();
    }



    function animateFalling() {
      if (!gameRunning) return;
      
      // Update trail positions
      asteroid.trail.push({ x: asteroid.x, y: asteroid.y });
      if (asteroid.trail.length > 15) {
        asteroid.trail.shift();
      }
      
      asteroid.x += asteroid.velocityX;
      asteroid.y += asteroid.velocityY;
      asteroid.rotation += 0.02;
      
      // Bounce off walls
      if (asteroid.x < asteroid.size || asteroid.x > canvas.width - asteroid.size) {
        asteroid.velocityX *= -1;
      }
      
      // Reset if off screen - penalty for missing
      if (asteroid.y > canvas.height + asteroid.size) {
        // Lose a point for missing (but can't go below 0)
        if (score > 0) {
          score--;
          if (scoreEl) scoreEl.textContent = String(score);
        }
        spawnFallingAsteroid();
      }
      
      updateObstacles();
      render();
      animationId = requestAnimationFrame(animateFalling);
    }

    function startGameMode() {
      // Stop existing animations
      if (animationId) cancelAnimationFrame(animationId);
      
      spawnFallingAsteroid();
      animateFalling();
    }

    function handleHit() {
      score++;
      if (scoreEl) scoreEl.textContent = String(score);
      
      // Create explosion effect
      createExplosion(asteroid.x, asteroid.y);
      
      // Immediate feedback - respawn with new properties
      setTimeout(() => {
        spawnFallingAsteroid();
      }, 100);
    }

    function checkHit(clickX, clickY) {
      const dist = Math.sqrt(
        (clickX - asteroid.x) ** 2 + (clickY - asteroid.y) ** 2
      );
      return dist < asteroid.size;
    }

    function checkObstacleClick(clickX, clickY) {
      for (let obs of obstacles) {
        const dist = Math.sqrt(
          (clickX - obs.x) ** 2 + (clickY - obs.y) ** 2
        );
        if (dist < obs.size) {
          return true;
        }
      }
      return false;
    }

    // Mouse/touch click handler
    canvas.addEventListener("click", (e) => {
      if (!gameRunning) return;
      
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const clickX = (e.clientX - rect.left) * scaleX;
      const clickY = (e.clientY - rect.top) * scaleY;

      // Check if clicked on obstacle first
      if (checkObstacleClick(clickX, clickY)) {
        loseLife();
        return;
      }

      // Then check if clicked on asteroid
      if (checkHit(clickX, clickY)) {
        handleHit();
      }
    });

    // Touch support for mobile
    canvas.addEventListener("touchstart", (e) => {
      if (!gameRunning) return;
      
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const clickX = (touch.clientX - rect.left) * scaleX;
      const clickY = (touch.clientY - rect.top) * scaleY;

      // Check if clicked on obstacle first
      if (checkObstacleClick(clickX, clickY)) {
        loseLife();
        return;
      }

      // Then check if clicked on asteroid
      if (checkHit(clickX, clickY)) {
        handleHit();
      }
    });





    // Start and restart handlers
    if (startBtn) startBtn.addEventListener("click", startGame);
    if (restartBtn) restartBtn.addEventListener("click", startGame);

    // Make canvas responsive
    function resizeCanvas() {
      const container = canvas.parentElement;
      if (container) {
        const maxWidth = Math.min(900, container.clientWidth - 32);
        const scale = maxWidth / 900;
        canvas.style.width = maxWidth + 'px';
        canvas.style.height = (700 * scale) + 'px';
      }
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
  </script>
</Layout>
